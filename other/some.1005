;; -*-lisp-*-

;;the top level node of director system

(include |ai:ken;declare >|)

(defcomment some) ;;for tags

(eval-when (eval) ;;the following is here only for its side effects
 (place-actor-on-name (make-actor nil 'something) 'something)
 ;;creates the guy it has no parent
 (let ((myself (actor-of 'something)))      
      (insert-method '(do once when receiving ?pattern %action)
		     '((let ((*replace-old-methods nil)) ;;so I don't clobber an old one
			    (insert-method pattern
					   '((remove-current-method) !,action)
					   myself)))
		     myself)
      (insert-method '(do when receiving ?pattern %action)
		     '((insert-method pattern action myself))
		     myself)
      (cond (*want-to-make-help-file
	     (save-help-on-file
	      'something
	      '(add-help-to-actor
		something
		(do when receiving ?pattern %action)
		(|do ACTION upon receipt of any messages matching PATTERN|)))
	     (save-help-on-file
	      'something
	      '(add-help-to-actor
		something
		(do once when receiving ?pattern %action)
		(|do ACTION the first time a message matching PATTERN is received|)))))))

(define-or-add-to something nil) ;;this is to be sure its compiled as one actor

(define-method (macro expand when receiving ?pattern %form) something
 (help-comments |Evaluate FORM twice when receiving a message matching PATTERN|)
 (insert-macro-method pattern form myself))

(define-method (recall your siblings) something
 (safe-delete myself
	      (let ((parent (ask myself recall your parent)))
		   (and parent (ask ,parent recall your offspring)))))

(define-method (recall your descendants) something
 (mapcan 'descendants-of-including-self (ask myself recall your offspring)))

(define-method (recall your childless-descendants) something
 (childless-descendants-of myself))

;;now for functions to travel down the hierarchy

(define-method-helper (childless-descendants-of actor) something
;;this returns the childless descendants of an actor, ie its descendants who have no offspring
 (let ((offspring (ask ,actor recall your offspring)))
      (cond (offspring
	     (mapcan 'childless-descendants-of offspring))
	    (t (list actor)))))

(define-method-helper (descendants-of-including-self actor) something
;;this returns the descendants of an actor, ie its offspring, its offsprings offspring, etc.
 (let ((offspring (ask ,actor recall your offspring)))
      (cond (offspring
	     (append (mapcan 'descendants-of-including-self offspring) (list actor)))
	    (t (list actor)))))

(define-primitive-method (recall your parent) something
 (parent-of myself))

(define-method (set your parent to ?new-parent) something
 (let* ((name (ask myself recall your name))
	(interned? (and name (internedp name))))
       (ask myself ask your parent remove ,name from your list of offspring)
       (change-parent-of myself (name-or-actor-of new-parent))
       (cond (interned? (ask ,new-parent add ,name to your list of offspring))))
 new-parent)

(define-method (set your whole to ?new-whole) something
 ;;if there was an old one then inform it of the change
 (let ((whole (ask myself recall your whole))
       (name (name-of myself)))
      (cond ((not (actor-eq (actor-of whole t) (actor-of new-whole t)))
	     (cond (whole (ask ,whole remove ,name from your list of parts)))
	     (and (exists? new-whole)
		  (cond ((and name (internedp name))
			 ;;if not won't keep back pointers so can GC
			 (ask ,new-whole add ,name to your list of parts))))))
      (do-old-behavior)))

(define-primitive-method (set your ?variable to ?value) something
 (help-comments |when asked "recall your" VARIABLE return VALUE|)
 (set-variable-to-value variable value))

(define-method-helper (set-variable-to-value variable value) something 
 (let* ((alists (internal-recall-your-variable-of myself))
	(old-pair (assq-assoc variable alists)))
       (cond (old-pair (replace-first (rest old-pair) value))
	     (t (let ((new-pair
		       (cond ((member variable (ask myself recall your private-variable-names))
			      (list variable value 'private))
			     (t (list variable value)))))
		     (add-variable-pair-to-actor variable alists new-pair)
		     (mapc
		      #'(lambda (synonym)
				(or (look-up-variable-in-actor synonym myself)
				    (add-variable-pair-to-actor synonym
								alists
								(cons synonym
								      (rest new-pair)))))
		      (second (assoc '(synonyms-of ,variable) (rest alists))))))))
 value)

(define-form (add-variable-pair-to-actor variable alists new-pair)
 (cond ((null alists)
	(make-internal-variables myself new-pair))
       ((symbolp variable)
	(cond ((first alists) (nconc (first alists) (list new-pair)))
	      (t (replace-first alists (list new-pair)))))
       (t (cond ((rest alists) (nconc (rest alists) (list new-pair)))
		(t (replace-rest alists (list new-pair)))))))


(define-primitive-method (recall your ?variable) something
			 (help-comments |recall the value of my VARIABLE|)
 (recall-value-of-variable variable))

(define-form (recall-value-of-variable variable)
 (do ((actor myself (parent-of actor)))
     ((null actor) nothing-found) ;;nil is default value for no value found
     (let ((pair (look-up-variable-in-actor variable actor)))
	  (cond (pair (return (second pair)))))))

(define-form (look-up-variable-in-actor variable actor)
 (let* ((alists (internal-recall-your-variable-of actor))
	(pair (assq-assoc variable alists)))
       (cond (pair 
	      (cond ((and (third pair) (not (actor-eq actor myself))) nil)
		    ;;if private and not mine then keep going else win
		    (t pair))))))

(define-method-helper (name-of actor) something
 (ask ,actor recall your name))

(define-method (forget your ?variable) something
 (help-comments |forget I ever heard about VARIABLE|)
 (forget-your-variable variable (internal-recall-your-variable-of myself) t))

(define-method-helper (forget-your-variable variable alists synonyms?) something
  (and synonyms? ;;clean up any synonyms
       (do ((synonyms (second (assoc '(synonyms-of ,variable) (rest alists))) (rest synonyms)))
	   ((null synonyms))
	   (forget-your-variable (first synonyms) alists nil)))
  (cond ((atom variable)
	 (let ((old-pair (assq variable (first alists))))
	      (cond (old-pair (replace-first alists (delq old-pair (first alists)))
			      no-value))))
	(t (let ((old-pair (assoc variable (rest alists))))
		(cond (old-pair (replace-rest alists (delq old-pair (rest alists)))
				no-value))))))

(define-method (forget everything) something
 (help-comments |restore my memory to its state at my birth|)
 (do ((i (ask myself list all your variable names) (rest i)))
     ((null i) no-value)
     (let ((variable-name (first i)))
	  (cond ((memq variable-name ;;leave it alone
		       '(name offspring whole parts synonyms)))
		(t (ask myself forget your ,variable-name))))))

(define-method (consider ?synonyms synonyms) something
 (help-comments |treat all the names in SYNONYMS as meaning the same thing|)
 (let* ((nothing-found (gensym)) ;;so I can tell if there's no value or is NIL
	(value-of-synonyms (value-of-synonyms synonyms)))
       (do ((s synonyms (rest s))
	    (previous nil)
	    (non-atomic-alist (rest (internal-recall-your-variable-of myself))))
	   ((null s)
	    (cond ((not (eq value-of-synonyms nothing-found))
		   (set-variable-to-value (first synonyms) value-of-synonyms))))
	   (ask myself set your (synonyms-of ,(first s))
		to ,(union (append previous (rest s))
			   (second (assoc '(synonyms-of ,(first s)) non-atomic-alist))))
	   (push (first s) previous))))

(define-form (value-of-synonyms synonyms)
 ;;there should either be no value or just one for all the synonyms
      (do ((s synonyms (rest s))
	   (value nothing-found) ;;value initially is nothing (not nil)
	   (alists (internal-recall-your-variable-of myself)))
	  ((null s) value)
	  (let ((new-value (recall-value-of-variable (first s))))
	       (cond ((eq new-value nothing-found)) ;;nothing there to worry about
		     ((equal new-value value)
		      (forget-your-variable (first s) alists nil)) ;;remove it to add later
		     ((eq value nothing-found) ;;haven't found a value yet
		      (setq value new-value)
		      (forget-your-variable (first s) alists nil))
		     (t (shouldnt-happen
			 'value-of-synonyms
			 '(|;Having trouble considering|
			   ,synonyms
			   |synonyms, since one has a value of| ,value
			   |while| ,(first s) |has a value of| ,new-value)))))))

(define-method (consider ?names components of ?variable) something
 (help-comments
  |VARIABLE is a list whose components can be accessed by the names in NAMES|)
 (ask myself set your (components of ,variable) to ,names)
 (let ((setting-components-method
	(ask myself do when receiving
	     (set your {memq ?element (quote ,names)} to ?value-of-element)
	     (set-value-of-element element value-of-element
				   (quote ,variable) (quote ,names)))))
      (ask myself do when receiving (set your ,variable to ?new-value)
	   ;;this is important if any demons are on the components
	   (do-old-behavior)
	   (set-each-component (quote ,names) new-value (quote ,setting-components-method))
	   new-value)
      (ask myself do when receiving (recall your {memq ?element (quote ,names)})
	   (recall-value-of-element element (quote ,variable) (quote ,names)))))
 
(define-method-helper (recall-value-of-element element variable names) something
 (do ((names names (rest names))
      (value (ask-old myself recall your ,variable) (rest value)))
     ((null names) (shouldnt-happen 'recall-value-of-element
				    '(|in "the name of elements of ..." of| ,myself)))
     (cond ((equal (first names) element)
	    (return (first value))))))

(define-method-helper (set-value-of-element element value-of-element variable the-names)
		      something
 (let ((original-value (top-level-copy (or (ask myself recall your ,variable)
					   ;;initially variable may not have a value so...
					   the-names))))
      (do ((names the-names (rest names))
	   (old-value original-value (rest old-value)))
	  ((null names) (shouldnt-happen myself
					 '(|bug in consider| ,the-names
							     |components of| ,variable)))
	  (cond ((equal (first names) element)
		 (cond ((listp old-value)
			(replace-first old-value value-of-element)
			(ask-old myself set your ,variable to ,original-value)
			(return value-of-element))
		       (t (shouldnt-happen 'set-value-of-element
					   '(|the value of| ,variable |is|
							    ,original-value
							    |which does not correspond to|
							    ,the-names)))))))))

(define-method-helper (set-each-component components values components-method) something
 (run-with-method-invisible
  (mapc
   #'(lambda (component value)
	     (ask myself set your ,component to ,value))
   components values)
  myself
  components-method))

(define-method (when representing ?pattern-for-variables use an array of size ?size) something
 (help-comments
  |variables whose name matches PATTERN-FOR-VARIABLES uses an array of SIZE|
  |this is just so that the variables are stored, retrieved and set more efficeintly|)
 (let* ((array-holder '(array-for ,pattern-for-variables))
	(old-array (ask myself recall your ,array-holder))
	(the-array (cond (old-array (*rearray old-array t size))
			 (t (*array (generate-symbol 'array) t size))))
	(variables-in-pattern (find-variables-in-pattern pattern-for-variables)))
       (ask myself set your ,array-holder to ,the-array)
       (ask myself do when receiving (recall your ,pattern-for-variables)
	    (,the-array !,variables-in-pattern))
       (ask myself do only for yourself when receiving
	    (set your ,pattern-for-variables to ?new-value)
	    (store (,the-array !,variables-in-pattern) new-value)))
 no-value)

(define-method (do only for yourself when receiving ?pattern %action) something
 (help-comments
  |do ACTION when I (but not if any of my descendants) receive a message matching PATTERN|)
 (ask myself do when receiving ,pattern
      (cond ((actor-eq myself (quote ,myself)) ;;its mine so its ok
	     !,action)
	    (t (do-old-behavior)))))

(define-macro-method (change your ?variable to ?value) something
 (help-comments |identical to set your VARIABLE to VALUE|)
 '(ask ,myself set your ,variable to ,value))

(define-macro-method (to %message) something
 ;;a little syntatic sugar for those that desire it
 '(ask ,myself !,message))

(define-macro-method (increment your ?variable by ?amount) something
		     (help-comments |add AMOUNT to the value of my VARIABLE|)
 '(ask ,myself set your ,variable to
       `(plus (or (ask ,myself recall your ,variable)
		  0) ;;if variable is new for example
	      (quote-if-need-be ,amount))))

(define-macro-method (multiply your ?variable by ?factor) something
 (help-comments |set VARIABLE to FACTOR times my current value or 1 if none|)
 '(ask ,myself set your ,variable to
       `(times (or (ask ,myself recall your ,variable)
		   1) ;;if variable is new for example
	       (quote-if-need-be ,factor))))

(define-macro-method (add ?value to your list of ?list-name) something
 (help-comments |add VALUE to the value of my LIST-NAME if not already there|)
 '(ask ,myself set your ,list-name to
       `(cons-if-not-member (quote-if-need-be ,value)
			    (ask ,myself recall your ,list-name))))

(define-macro-method (add ?value to your list of ?variable regardless) something
 (help-comments |add VALUE to the value of my LIST-NAME even if already there|) 
 ;;this differs from add ? to your list of .. in that duplicates are ok
 '(ask ,myself set your ,variable to
	`(cons (quote-if-need-be ,value) (ask ,myself recall your ,variable))))

(define-macro-method (remove ?element from your list of ?list-name) something
 (help-comments |remove from my LIST-NAME any values that match the ELEMENT|) 
 '(ask ,myself set your ,list-name to
       `(safe-delete (quote-if-need-be ,element) (ask ,myself recall your ,list-name))))

(define-method (list all your variable names) something
 (help-comments |return the names of all my variables (do not include my parent's variables)|)
 (collect-all-variable-names myself))

(define-method (recall each of your ?variable-pattern) something
 (help-comments
  |recall all the values of all my variables whose name matches the VARIABLE-PATTERN|) 
 (do ((i (ask myself list all your variable names) (rest i))
      (matching-names nil))
     ((null i)
      (mapcar
       (function (lambda (variable-name)
			 (ask myself recall your ,variable-name)))
       matching-names))
     (cond ((match (first i) variable-pattern) (push (first i) matching-names)))))

(define-method (make an instance named ?name copying ?variables-to-copy) something
 ;;this returns the actor made and does not place it anywhere
 ;;they also do not have a name
 (cond (variables-to-copy
	(let ((new-actor (make-actor (actor-of 'something) name)))
	     ;;initially use top node since copying should not trigger demons
	     (mapc (function (lambda (variable-to-copy)
				     (ask ,new-actor set your ,variable-to-copy to
					  ,(ask myself recall your ,variable-to-copy))))
		   variables-to-copy)
	     (ask ,new-actor set your parent to ,myself)
	     new-actor))
       (t ;;this is just a more efficient version of above
	(make-actor myself name))))

(define-macro-method (make) something
 (help-comments |return a disembodied name-less instance of myself|)
 '(ask ,myself make nil))

(define-method (make ?name) something
	       (help-comments |make an instance of myself with NAME|)
 ;;this makes an instance of an actor by initializing all the properties
 (let ((old-version (actor-of name dont-autoload))) ;;and one already exists
      ;;dont want to use exists since should not autoload it just to unmake it      
      (cond ((and (not *replace-old-actors) name)
	     (cond ((ask ,name unmake)
		    ;;if protected will return NIL and so this wont happen
		    (ask myself !,*message))))
	    (t
	     (let ((new-version
		    (ask myself make an instance named ,name copying
			 ,(ask myself recall your variables-to-copy-upon-creation))))
		  (cond ((null name) new-version) ;;without a name just return the actor
			((null old-version)
			 (place-actor-on-name new-version name)
			 (cond ((internedp name)
				;;only if interned should parent know about offspring
				(ask myself add ,name to your list of offspring)))
			 name)
			((cond ((member name *protected-actors)
				(protected-actor-but-ok name))
			       (t t))
			 (let ((whole (ask ,old-version recall your whole)))
			      (and whole (ask ,whole remove ,name from your list of parts)))
			 (cond ((not (actor-eq (parent-of old-version) myself)) ;;new parent
				(ask ,(parent-of old-version)
				     remove ,name from your list of offspring)
				(cond ((internedp name)
				       ;;if interned should parent know about offspring
				       (ask myself add ,name to your list of offspring)))))
			 (recycle-old-actor old-version new-version)
			 name)))))))

(define-method (make up a name) something
 (help-comments |makes up an atomic name that is known by the reader|)
 (intern-append-atoms (name-of myself)
		      '-
		      (ask myself increment your name-counter by 1)))

(define-method (make up an uninterned name) something
 (help-comments |makes up an atomic name that is NOT known by the reader|)
 (append-atoms (name-of myself)
	       '-
	       (ask myself increment your name-counter by 1)))

(define-method (if new make ?name) something
 (help-comments |if no one with that name exists make an instance of myself|) 
 (cond ((exists? name) name) ;;already exists so do nothing
       (t (ask myself make ,name))))

(define-method (clone) something
 (help-comments |make and return an identical copy of myself without a name or offspring|)
 (clone-actor nil))

(define-method (clone and name it ?name) something
 (help-comments |make and return an identical copy of myself and call it NAME|)
 (clone-actor (list name)))

(define-method-helper (clone-actor list-of-name) something
  (let* ((name-or-new-actor (ask myself ask your parent to make !,list-of-name))
	 (new-actor (actor-of name-or-new-actor))
	 (old-methods-copy (top-level-copy (methods-of myself))))
      (replace-rest (methods-of new-actor) (rest old-methods-copy))
      (set-body-of-method (first (methods-of new-actor))
			  (copy-internal-variable-alist
			   (body-of-method (first (methods-of myself))) new-actor))
      (cond (list-of-name (ask ,new-actor set your name to ,name-or-new-actor))
	    (t (ask ,new-actor forget your name) ;;shouldn't have a name
	       new-actor))))

(define-method-helper (copy-internal-variable-alist alists new-actor) something
 (let ((substitution-alist
	(append
	 (mapcar
	  (function
	   (lambda (child)
		   (let ((copy (ask ,child clone)))
			(ask ,copy set your parent to ,new-actor)
			(cons (actor-of child) copy))))
	  (second (assq 'offspring (first alists))))
	 (mapcar
	  (function
	   (lambda (part)
		   (let ((copy (ask ,part clone)))
			(ask ,copy set your whole to ,new-actor)
			(cons (actor-of part) copy))))
	  (second (assq 'parts (first alists)))))))
      (cons (substitute-in-alist (first alists) substitution-alist)
	    (substitute-in-alist (rest alists) substitution-alist))))

(define-method (make synonym ?name) something
  ;;name is the same actor not even the name is changed
 (help-comments  |make another name for myself|)
 (ask myself add ,name to your list of synonyms)
 (synonym-for myself name))

(define-method (absorb your parts) something
 (help-comments |makes all my parts accessible only through me by name|)
 (mapc
  (function (lambda (part)
		    (let ((part-name (name-of part))
			  (part-actor (actor-of part)))
			 (ask ,part-actor disembody) ;;make it inacessible
			 (ask myself set your ,part-name to ,part-actor)
			 (ask ,part-actor absorb your parts))))
  (ask myself recall your parts))
 no-value)

(define-method (remob) something
 ;;renames it to an uninterned name and changes the world accordingly
 (general-remprop (name-of myself) 'actor 'non-atomic-actors)
 (let ((new-name
	(ask myself set your name
	     to ,(generate-symbol (or (name-of myself) '|unnamed-actor|)))))
      (place-actor-on-name myself new-name)
      new-name))

(define-method (disembody) something
 (help-comments |forget I ever had a name and come back "disembodied"|)
 ;;returns the actor and removes its name
 ;;it replaces its name with itself in the part/whole links
 (let ((name (ask myself recall your name))
       (whole (ask myself recall your whole)))
      (cond (name (ask-if-exists ,whole remove ,name from your list of parts)))
      (ask myself ask your whole add ,myself to your list of parts)
      (ask myself ask each of your parts to set your whole to ,myself)
      (general-remprop (name-of myself) 'actor 'non-atomic-actors)
      (ask myself forget your name)
      myself))

(define-method (unmake) something
 (help-comments |kill myself --- to be used with CARE|) 
 (let ((name (name-of myself)))
      (cond ((member name *protected-actors)
	     (and (protected-actor-but-ok name)
		  (ask myself unmake)))
	    ((or (not *protect-all-actors)
		 (cond ((ask myself recall your name) ;;if doesn't have a name dont ask user
			(ask-if '(|do you really want to destroy|
				  ,(or name myself)
				  |and all its parts and offspring?|)))
		       (t t)))
	     (let ((parent (parent-of myself)))
		  (cond (parent ;;ie if not top guy
			 (ask ,parent remove ,name from your list of offspring))))
	     (cond ((ask myself recall your things-to-do-next) ;;if have anything planned
		    (ask myself ask your clock
			 remove ,myself from your list of actors-to-run-next)))
	     (let ((whole (ask myself recall your whole)))
		  (ask-if-exists ,whole remove ,name from your list of parts))
	     (let ((*protect-all-actors nil)) ;;already okayed this
		  (ask myself ask each of your parts to unmake)
		  (ask myself ask each of your offspring to unmake)
		  (ask myself untrace)) ;;remove any traces for this guy
	     (mapc 'remove-actor-from-name (ask myself recall your synonyms))
	     (remove-actor-from-name name)
	     no-value))))

(define-form (protected-actor-but-ok name)
 (shouldnt-happen name
		  '(|You are trying to unmake me and I'm protected.  Type (?) for help.|)
		  '(|type "p " and I'll ignored this./
If you really want to kill| ,name |then remove its name from the variable *protected-actors/
and then type "(return t)"|)))

(define-method (memorize ?item) something
 (help-comments |memorize the ITEM provided|) 
 (ask myself add ,item to your list of internal-name-of-items-memorized)
 no-value)

(define-method (forget item ?item) something
 (help-comments |forget the ITEM. Also see "forget items matching ?pattern".|)
 (ask myself remove ,item from your list of internal-name-of-items-memorized)
 no-value)

(define-method (recall all possible items matching ?) something
 (help-comments (pattern-is (recall all possible items matching ?pattern))
		|come up with a list of items that might possibly match PATTERN|)
 ;;this is the hook for adding virtual items
 (ask myself recall your internal-name-of-items-memorized))

(define-macro-method (recall an item matching ?pattern then %action) something
 (help-comments |find an item that matches PATTERN and then do the ACTION|)
 (make-keep-sending-type-body 'keep-sending-items-til-match pattern action))

(define-macro-method (recall each item matching ?pattern then %action) something
 (help-comments |find all items that match PATTERN and do ACTION for each one|)
 (make-keep-sending-type-body 'keep-sending-items-collecting-all pattern action))

(define-form (make-keep-sending-type-body sending-function pattern action)
 (let* ((pattern-form (quote-allowing-eval-and-unpack pattern))
	(action-form (quote-allowing-eval-and-unpack action))
	(database-method-form '(make-normal-method ,pattern-form ,action-form)))
       (cond ((and (quoted? pattern-form) (quoted? action-form))
	      (list sending-function
		    pattern-form
		    (list 'quote-sharp-comma database-method-form)
		    myself))
	     (t ;;otherwise have to generate the method at run time
	      '(,sending-function ,pattern-form
				  ,database-method-form
				  ,myself)))))

(define-method-helper (keep-sending-items-til-match pattern database-method actor) something
 (do ((actor actor (parent-of actor))
      (method-predicate (method-pattern-predicate database-method)))
     ((null actor) nothing-found)
     (let* ((items (ask ,actor recall all possible items matching ,pattern))
	    (result (cond ((null items) nil)
			  ((symbolp method-predicate)
			   (run-first-to-match items
					       database-method
					       method-predicate))
			  (t (run-first-thats-equal items
						    database-method
						    pattern)))))
	   (cond ((eq result 'director-symbol-for-nothing-found)) ;;keep trying
		 (t (return result))))))

(define-form (run-first-to-match items method method-predicate)
 (do ((i items (rest i)))
     ((null i) 'director-symbol-for-nothing-found)
     (cond ((funcall method-predicate (first i))
	    (let ((*message (first i)))
		 (return (run-method method)))))))

(define-form (run-first-thats-equal items method method-pattern)
 (do ((i items (rest i)))
     ((null i) 'director-symbol-for-nothing-found)
     (cond ((equal method-pattern (first i))
	   (let ((*message (first i)))
		(return (run-method method)))))))

(define-method-helper (keep-sending-items-collecting-all pattern database-method actor)
		      something
 (do ((actor actor (parent-of actor))
      (method-predicate (method-pattern-predicate database-method))
      (results nil))
     ((null actor) (or (nreverse results) no-value))
     (let ((items (ask ,actor recall all possible items matching ,pattern)))
	  (cond ((symbolp method-predicate)
		 (do ((i items (rest i)))
		     ((null i))
		     (cond ((funcall method-predicate (first i))
			    (let ((*message (first i)))
				 (push (run-method database-method) results))))))
		(t (do ((i items (rest i)))
		       ((null i))
		       (cond ((equal pattern (first i))
			      (let ((*message (first i)))
				   (let ((result (run-method database-method)))
					(cond ((not (eq result no-value))
					       (push result results)))))))))))))

(define-method (collect items memorized matching ?pattern) something
 (help-comments
  |collect all those items memorized by me and my ancestors that match the PATTERN|)
  (ask myself recall each item matching {and ?the-item ,pattern} then the-item))

(define-method (forget items matching ?pattern) something
 (help-comments |forget any item memorized that matches PATTERN|) 
 (ask myself recall each item matching {and ?the-item ,pattern} then
      (script (ask myself forget item ,the-item))))

(define-method (tick) something
 (help-comments |do all the things that are the value of my things-to-do-next|) 
  (let ((things (ask ,myself recall your things-to-do-next)))
       (ask ,myself set your things-to-do-next to nil)
       (ask ,myself concurrently !,things)
       things)) ;;returns the things done

(define-method (plan after receiving ?event-pattern to ?message-form) something
 ;;message-form gets evaluated and sent to actor in plan next message when event-patern is met
 (help-comments |send myself the value of MESSAGE-FORM|
		|the first time I receive a message matching the EVENT-PATTERN|)
 (let ((*replace-old-methods nil)) ;;dont want to clobber old one
      (ask myself do once when receiving ,event-pattern
	   (let ((new-message ,message-form))
		(script (let ((result (ask-old-if-understood myself !,*message)))
			      ;;the actor need not be able to respond to the *message
			      (and new-message (ask myself !,new-message))
			      result))))))

;;(define-method (plan after receiving ?event-pattern to always ?message-form) something
;; (help-comments |always send myself the value of MESSAGE-FORM|
;;		 |upon receiving a message matching EVENT-PATTERN|) 
;; (let ((*replace-old-methods nil)) ;;dont want to clobber old one
;;      (ask myself do when receiving ,event-pattern
;;	   (let ((new-message ,message-form))
;;		(script (let ((result (ask-old-if-understood myself !,*message)))
;;			      ;;the actor need not be able to respond to the *message
;;			      (and new-message (ask myself !,new-message))
;;			      result))))))

(define-macro-method (do {or at in} ? ? %) something
 ;;this is so that I only have to pick up the "gradually" and "do at speed" guys
 ;;with a "sequentially" in front
 '(ask ,myself sequentially `*message))

(define-macro-method ({memq ?action '(plan gradually repeat ask broadcast)} %rest) something
 '(ask ,myself sequentially (,action !,rest)))

(define-macro-method (sequentially (plan next %message) %followup) something
 (help-comments (pattern-is (plan next %message))
		|plan to do on the next tick the MESSAGE|) 
 ;;moves the "sequentially" inside the message 
 '(ask ,myself plan after 1 ticks sequentially ,message !,followup))


(define-method (sequentially (plan after ?number ?units %message) %followup) something
 (help-comments (pattern-is (plan after ?number ?units %message))
		|plan to receive MESSAGE after NUMBER UNITS (ticks, frames or seconds)|)
 (let* ((message (message-with-followup message followup))
	(number (number-of-ticks number units))
	(whats-planned-already (ask myself recall your things-to-do-next))
	(list-of-new-command (cond ((< number 1) nil) ;;nothing to do
				   ((= number 1) (list message))
				   (t '((plan after ,(1- number) ticks !,message))))))
       (cond (whats-planned-already (nconc whats-planned-already list-of-new-command))
	     ;;the nconc serves two functions (1) put it at the end
	     ;;(2) updates do-stuff-planned dynamically (and automatically)
	     (t (ask myself set your things-to-do-next to ,list-of-new-command)
		(let ((clock (actor-of (ask myself recall your clock))))
		     (cond ((and (not (actor-eq myself clock)) ;;only if not the clock
				 list-of-new-command) ;;and there really is something planned
			    (ask ,clock add ,myself to your list of actors-to-run-next)))))))
 no-value)

(define-form (message-with-followup message followup)
 (cond (followup '(sequentially ,message !,followup))
       (t message)))


(define-method (stop everything) something
 (help-comments
  |Forget all the things I've planned to do later (takes effect on the next tick)|)
 ;;don't do any of the things about to be planned during this tick for later
 (ask myself do once when receiving (tick)
      (ask myself forget your things-to-do-next)))

(define-method (wait for %signal) something
 (help-comments
  |Don't doing any of the current things planned until getting a SIGNAL message|)
 (ask myself do once when receiving (tick)
      (ask myself do once when receiving ,signal
	   (ask-old-if-understood myself !,signal) ;;might not do anything
	   (ask myself concurrently !,(ask myself recall your things-to-do-next)))
      (ask myself forget your things-to-do-next)))

(define-macro-method (sequentially (concurrently %actions) %followup) something
 ;;this one of the few who have to catch the "followup" explictly
 (help-comments (pattern-is (concurrently %actions))
		|do all the ACTIONS in parallel (a little bit each tick)|)
 (let ((activity-name (generate-symbol 'activity)))
      '(ask ,myself concurrently
	    (set your ,activity-name to ,actions)
	    (do once when receiving (set your ,activity-name to nil)
		(ask myself forget your ,activity-name)
		(ask myself sequentially !,followup))
	    !,(mapcar
	       #'(lambda (action)
			 '(sequentially
			   ,action
			   (ask ,myself remove ,action from your list of ,activity-name)))
	       actions))))

(define-method (concurrently %messages) something
 (body-of-do-the-following messages))

(define-method (do the following %messages) something
 ;;the "concurrently" one is really sequential when they are non-planning messages
 ;;so this is a better name in that case
 (body-of-do-the-following messages))

(define-method-helper (body-of-do-the-following messages) something
 (do ((m messages (rest m))
      (last-value))
      ((null m) last-value)
      (let ((*message (first m)))
	   (setq last-value (cases myself)))))

(define-macro-method (sequentially (repeat ?message forever) %followup) something
 (help-comments (pattern-is (repeat ?message forever))
  |do the MESSAGE and when finished plan on the next tick to repeat forever the same message|) 
 '(ask ,myself sequentially
       ,message
       (plan next repeat ,message forever)
       !,followup)) ;;followup will never happen though

(define-method (sequentially (repeat ?message ?number times) %followup) something
 (help-comments (pattern-is (repeat ?message ?number times))
  |do the MESSAGE and when finished plan on the next tick to repeat one less time the MESSAGE|)
  (let ((number (fix number)))
       (cond ((> number 0)
	      (ask ,myself sequentially
		   ,message
		   (plan next repeat ,message ,(1- number) times)
		   !,followup)))))

(define-method (sequentially
		(do at speed ?speed ask ?other {or set change} your ?variable to ?value)
		%followup)
	       something
	       (set-gradually myself other variable value speed followup *message))

(define-method (sequentially (do at speed ?speed {or set change} your ?variable to ?value)
			     %followup)
	       something
 (help-comments
  (pattern-is (do at speed ?speed {or set change} your ?variable to ?value))
  |slowly change my VARIABLE to VALUE at a speed of SPEED units per second|)
	       (set-gradually myself myself variable value speed followup *message))

(define-method (sequentially (do in ?number ?units %action ?amount) %followup) something
 (help-comments (pattern-is (do in ?number ?units %action))
		|Take NUMBER of UNITS to gradually do ACTION|)
 (do-at-speed (quotient (float amount) (number-of-ticks number units))
	      action
	      amount
	      followup))

(define-method (sequentially (do at speed ?speed %action ?amount) %followup) something
 (help-comments (pattern-is (do at speed ?speed %action))
		|gradually do ACTION at a speed of SPEED units per second|)
 (do-at-speed (times speed (number-of-ticks 1.0 'second)) action amount followup))

(define-method-helper (do-at-speed speed-in-ticks action amount followup) something
 (ask myself sequentially
      (repeat (!,action ,speed-in-ticks)
	      ,(quotient (float amount) speed-in-ticks) times)
      !,followup))

(define-method (sequentially (gradually ask ?other {or set change} your ?variable to ?value)
			     %followup) something
	       (set-gradually myself other variable value nil followup *message))

(define-method (sequentially (gradually {or set change} your ?variable to ?value) %followup)
	       something
 (help-comments (pattern-is (gradually {or set change} your ?variable to ?value))
		|gradually change the value of VARIABLE to VALUE at (VARIABLE speed)|)
	       (set-gradually myself myself variable value nil followup *message))

(define-method-helper (set-gradually planner doer variable value speed followup the-message)
		      something
 (cond ((listp value)
	(set-gradually-list planner doer variable value followup))
       ((numberp value)
	(set-gradually-number planner doer variable value speed followup the-message))
       (t (shouldnt-happen 'set-gradually
			   '(|attempting to gradually set|
			     ,variable to ,value |which is neither a number or a list|)))))

(define-method-helper (set-gradually-list planner doer variable value followup) something 
 (let ((element-names (ask ,doer recall your (components of ,variable))))
      (cond (element-names
	     (ask ,planner sequentially
		  (concurrently
		      !,(do ((names element-names (rest names))
			     (values value (rest values))
			     (messages nil))
			    ((or (null names) (null values))
			     (cond ((and (null values) (null names)) messages)
				   (t (shouldnt-happen 'set-gradually
						       '(|attempting to gradually set|
							 ,variable |to|
							 ,value |while its elements are|
							 ,element-names)))))
			    (push
			     '(gradually ask ,doer set your ,(first names) to ,(first values))
			     messages)))
		  !,followup))
	    (t (shouldnt-happen 'set-gradually
				'(|attempting to gradually set|
				  ,variable to ,value
				  |but there is no value of| (element-names-of ,variable)))))))

(define-method-helper (set-gradually-number
		       planner doer variable value speed followup the-message)
		      something 
 (let ((speed (or speed (ask ,doer recall your (,variable speed))))
       (distance (difference value (or (ask ,doer recall your ,variable) 0.0))))
      (cond ((null speed)
	     (ask ,doer consider (default-speed (,variable speed)) synonyms)
	     (warning 'set-gradually
		      '(,doer |has no| (,variable speed) |so, default-speed|
				,(setq speed (ask ,doer recall your (,variable speed)))
				|units//second assumed.|))))
      (cond ((minusp distance) (setq speed (minus speed))))
      (cond ((greaterp (abs distance) (abs speed)) ;;cant do it all in one fell swoop
	     (ask ,doer increment your ,variable by ,speed)
	     (ask ,planner plan next !,the-message))
	    (t (ask ,doer set your ,variable to ,value)
	       (ask ,planner sequentially !,followup)))))

(define-method (sequentially (gradually ask ?other %action ?amount) %followup) something
 (do-gradually myself other action amount followup))

(define-method (sequentially (gradually %action ?amount) %followup) something
 (help-comments (pattern-is (gradually %action ?amount))
  |gradually do whatever the ACTION at my speed named (!,ACTION speed)|)
  (do-gradually myself myself action amount followup))


(define-method-helper (do-gradually planner doer action amount followup) something
 (cond ((numberp amount) (do-gradually-number planner doer action amount followup))
       ((listp amount) (do-gradually-list planner doer action amount followup))
       (t (shouldnt-happen 'do-gradually
			   '(|;Attempting to gradually| (!,action ,amount) |/
but| ,amount |is neither a number nor a list|)))))

(define-method-helper (do-gradually-list planner doer action amount followup) something
 (let ((components (ask ,doer recall your (components of !,action))))
      (cond ((null components)
	     (shouldnt-happen
	      'do-gradually-list
	      '(|;Attempting to gradually| (!,action ,amount) |/
but| ,amount |is a list and| ,doer |doesn't know the| (components of !,action))))
	    (t (do ((c components (rest c))
		    (values amount (rest values))
		    (component-actions nil))
		   ((or (null c) (null values))
		    (cond ((and (null c) (null values))
			   (ask ,planner sequentially
				(concurrently !,component-actions)
				!,followup))
			  (t (shouldnt-happen
			      'do-gradually
			      '(|;Attempting to gradually|
				(!,action ,amount) |but| ,amount
				|does not have the same number of elements as|
				(components of !,action) |which is| components)))))
		   		(push '(gradually ,(first c) ,(first values))
				      component-actions))))))

(define-method-helper (do-gradually-number planner doer action amount followup) something
 (let ((speed (ask ,doer recall your (!,action speed))))
      (cond ((null speed)
	     (ask ,doer consider (default-speed (!,action speed)) synonyms)
	     (warning 'do-gradually
		      '(,doer |has no| (!,action speed) |so, default-speed|
				,(setq speed (ask ,doer recall your (!,action speed)))
				|units//second assumed.|))))
      (cond ((eq-first speed 'add) (setq speed (second speed))))
      (cond ((numberp speed)
	     (do-gradually-at-speed speed planner doer action amount followup))
	    ((eq-first speed 'multiply-by)
	     (do-gradually-at-rate (second speed) planner doer action amount followup))
	    (t (shouldnt-happen 'do-gradually
				'(,doer |has a| (!,action speed) of ,speed
					|which is not recognized|))))))

(define-method-helper (do-gradually-at-speed speed planner doer action amount followup)
		      something
 (let ((speed (speed-in-ticks speed)))
      (cond ((not (lessp speed (abs amount)))
	     (ask ,doer !,action ,amount)
	     (ask ,planner sequentially !,followup))
	    ((minusp amount)
	     (ask ,doer !,action ,(minus speed))
	     (ask ,planner plan next sequentially
		  (gradually ask ,doer !,action ,(plus amount speed))
		  !,followup))
	    (t (ask ,doer !,action ,speed)
	       (ask ,planner plan next sequentially
		   (gradually ask ,doer !,action ,(difference amount speed))
		    !,followup))))
 '|begun|)

(define-method-helper (do-gradually-at-rate rate planner doer action amount followup)
		      something
 (let ((rate (rate-in-ticks rate)))
      (cond ((not (lessp rate (cond ((< amount 1.0) (//$ amount))
				    (t amount))))
	     (ask ,doer !,action ,amount)
	     (ask ,planner sequentially !,followup))
	    ((< amount 1.0)
	     (ask ,doer !,action ,(//$ rate))
	     (ask ,planner plan next sequentially
		  (gradually ask ,doer !,action ,(*$ rate amount))
		  !,followup))
	    (t (ask ,doer !,action ,rate)
	       (ask ,planner plan next sequentially
		    (gradually ask ,doer !,action ,(//$ amount rate))
		    !,followup))))
 '|begun|)


(define-method-helper (number-of-ticks number units) something
 ;;converts seconds and frames to ticks
 (cond ((memq units '(ticks tick)) number)
       ((memq units '(frames frame))
	(round (times (float number) (ask myself ask your clock recall your ticks-per-frame))))
       ((memq units '(seconds second))
	(let ((clock (ask myself recall your clock)))
	     (round (times (float number)
			   (ask ,clock recall your frames-per-second)
			   (ask ,clock recall your ticks-per-frame)))))
       (t (shouldnt-happen 'number-of-ticks
			   '(,units |is an invalid unit of time|)
			   '(|type "p " and the message will be ignored|))
	  0)))

(define-method-helper (speed-in-ticks speed-per-second) something
 (let ((clock (ask myself recall your clock)))
      (//$ (float speed-per-second)
	   (float (ask ,clock recall your frames-per-second))
	   (float (ask ,clock recall your ticks-per-frame)))))

(define-method-helper (rate-in-ticks rate-per-second) something
 (let* ((clock (ask myself recall your clock))
	(ticks-per-second
	 (float (times (float (ask ,clock recall your frames-per-second))
		       (float (ask ,clock recall your ticks-per-frame))))))
       ;;the following is a little math to compute the rate per tick
       (exp (//$ (log (float rate-per-second)) ticks-per-second))))

(define-method-helper (length-in-frames length units) something
 (cond ((memq units '(ticks tick))
	(round (quotient (float length)
			 (ask myself ask your clock recall your ticks-per-frame))))
       ((memq units '(seconds second))
	(let ((clock (ask myself recall your clock)))
	     (round
	      (times (ask ,clock recall your frames-per-second)
		(quotient (float length)
			  (ask ,clock recall your ticks-per-frame))))))
       ((memq units '(frames frame)) length)
       (t (shouldnt-happen
	   'length-in-frames
	   '(,units |is an invalid unit (ticks, seconds, or frames are ok)|)
	   '|type "p " and the message will be ignored|)
	  0)))

(define-method-helper (length-in-seconds length units) something
 (cond ((memq units '(ticks tick))
	(let ((clock (ask myself recall your clock)))
	     (quotient (float length)
		       (ask ,clock recall your ticks-per-frame)
		       (ask ,clock recall your frames-per-second))))
       ((memq units '(seconds second)) length)
       ((memq units '(frames frame))
	(quotient (float length)
		  (ask myself ask your clock recall your frames-per-second)))
       (t (shouldnt-happen
	   'length-in-frames
	   '(,units |is an invalid unit (ticks, seconds, or frames are ok)|)
	   '|type "p " and the message will be ignored|)
	  0)))

;;now for broadcasting and rerouting of messages

(define-method (sequentially (broadcast or ask your ?others-name %message) %followup) something
 (help-comments (pattern-is (broadcast or ask your ?others-name %message))
		|If I know of any variable OTHERS-NAME then I ask the actors them to broadcast|
		|otherwise I send the MESSAGE to myself|)
 (let ((others (ask myself recall your ,others-name)))
      (cond (others
	     (director-mapcan
	      (function (lambda (other)
				(ask ,other !,*message)))
	      others))
	    (t (let ((result (cond (followup (ask myself sequentially ,message !,followup))
				   (t (ask myself !,message)))))
		    (cond (result (list result))))))))

(define-method (sequentially (broadcast to your ?others-name %message) %followup) something
 (help-comments (pattern-is (broadcast to your ?others-name %message))
		|If I know of any variable OTHERS-NAME then I ask the actors them to broadcast|
		|in any case, I send the MESSAGE to myself|)
 (let* ((others (ask myself recall your ,others-name))
	(result (cond (followup (ask myself sequentially ,message !,followup))
		      (t (ask myself !,message))))
	(results-of-others
	 (director-mapcan
	  (function (lambda (other)
			    (ask ,other !,*message)))
	  others)))
       (cond ((eq results-of-others no-value) (list result))
	     ((and result (not (eq result no-value)))
	      (cons result results-of-others))
	     (t results-of-others))))

(define-method (sequentially (ask your ?variable %message) %followup) something
 (help-comments (pattern-is (ask your ?variable %message))
		|recall the value of my VARIABLE and then ask it the MESSAGE|)
 (let ((other (ask ,myself recall your ,variable)))
      (cond (other (cond (followup (ask ,other sequentially ,message !,followup))
			 (t (ask ,other !,message))))
	    (t (shouldnt-happen myself
				'(|I don't have any| ,variable |to ask| !,message))))))

(define-method (sequentially (ask each of your ?variable %message) %followup) something
 (help-comments (pattern-is (ask each of your ?variable %message))
		|recall the value of VARIABLE and ask each member of it the MESSAGE|)
 (cond (followup
	(ask-each ,(ask ,myself recall your ,variable) sequentially ,message !,followup))
       (t (ask-each ,(ask ,myself recall your ,variable) !,message))))

(define-method (sequentially (ask each of ?others %message) %followup) something
 (help-comments (pattern-is (ask each of ?others %message))
		|ask each member of the list OTHERS the MESSAGE|) 
 (cond (followup
	(ask-each ,others sequentially ,message !,followup))
       (t (ask-each ,others !,message))))

(define-method (sequentially (ask ?another %message) %followup) something
 (help-comments (pattern-is (ask ?another %message))
		|ask ANOTHER the MESSAGE|) 
 (cond (followup (ask ,another sequentially ,message !,followup)) ;;useful for planning
       (t (ask ,another !,message))))


(define-method (sequentially %actions) something
 ;;this has to be the last in the planning group since special cases live above it
 (help-comments |do each of the ACTIONS sequentially waiting for each one to finish|)
 (cond ((null actions) no-value)
       ((one-long actions) (ask myself !,(first actions)))
       (t (ask myself !,(first actions))
	  ;;if the first of actions is a "time-consumer" then it should have caught it earlier
	  (ask myself sequentially !,(rest actions)))))

(define-method (keep doing until ?predicate %message) something
 (help-comments
  |keep sending MESSAGE to myself until the value returned is true of the Lisp PREDICATE|)
 (do ((result (ask myself !,message) (ask myself !,message)))
     ((funcall predicate result) result)))

;;this is where odds and ends in something go

(define-method (are you {or a an} ?type) something ;;an concession to English
 ;;this finds out if any ancestor is named type
 (help-comments |am I or any of my ancestors named TYPE?|)
  (is-any-ancestor-of myself (actor-of type)))
 
;;now for a few useful utility functions

(define-function is-any-ancestor-of (actor other)
 (cond ((null actor) nil)
       ((actor-eq actor other) actor)
       (actor (is-any-ancestor-of (parent-of actor) other))))

(define-method (find ancestor matching ?name-pattern) something
 (help-comments |look for an ancestor whose name matches NAME-PATTERN|)
 ;;if any ancestor matches the name-pattern
 (let ((name (name-of myself)))
      (cond ((match name name-pattern) myself)
	    (t (let ((parent (parent-of myself)))
		    (cond (parent (ask ,parent !,*message))))))))
 
(define-primitive-method (recall internal method for %message) something
 (help-comments |returns the internal name of the method that catches the MESSAGE|) 
  (method-that-matches (methods-of myself) message))

(define-primitive-method (recall method for %message) something
 (help-comments
  |return the pattern and action of the first receive method to catch the MESSAGE|) 
 ;;returns the method for the message in the format (<pattern> <action-function>)
 (humanify-method (method-that-matches (methods-of myself) message)))


(define-primitive-method (remove method for %message) something
 (help-comments |remove the first method of my own that catches the MESSAGE|) 
 (remove-method (method-that-matches-just-actor myself message) myself))

(define-method (trace %pattern+action) something
 (help-comments (pattern-is (trace ?pattern %action))
  |trace any message that matches PATTERN and do ACTION or if one exists|
  |(Untrace) will remove the trace|)
 (director-trace myself (first pattern+action) (rest pattern+action)))

(define-method (untrace ?pattern) something
 (help-comments |remove any traces whose pattern matches this PATTERN|) 
 (director-untrace myself pattern))

(define-method (untrace) something ;;untrace all so ...
 (help-comments |remove any trace of a trace on me|)
 (let ((myself+tracer (assq myself *actors-currently-traced)))
      (and myself+tracer (director-untrace-all myself+tracer))))

(define-method (constrain your ?variable to equal ?function of ?others-variable of ?other)
	       something
 (help-comments |keep the value of my VARIABLE always equalling|
		|the FUNCTION of the value of the OTHER's OTHERS-VARIABLE|)
 (ask ,other do when receiving (set your ,others-variable to ?new-value)
      (ask-old ,myself set your ,variable to `(,function new-value))
      (do-old-behavior)))

(define-method (tell each of your ?others whenever your ?variable is changed) something
 ;;I think this should be a macro so that it will compile for the guy involved
 (cond ((member variable (ask myself recall your (variables-depended-upon-by ,others))))
       (t ;;didn't know already so ...
	(ask myself add ,variable to your list of (variables-depended-upon-by ,others))
	(ask myself do when receiving (set your ,variable to ?new-value)
	     (do-old-behavior) ;;do it as normal
	     (tell-others-new-value (quote ,variable) new-value (quote ,others))
	     new-value))))

(define-method-helper (tell-others-new-value variable new-value groups-name) something
 (ask myself ask each of your ,groups-name
      notice that ,variable of ,myself is now ,new-value))

(define-method (tell your ?other whenever your ?variable is changed) something
 (ask myself ask your ,other to notice that ,variable of ,myself is now
      ,(ask myself recall your ,variable))
 (ask myself add ,variable to your list of (variables-depended-upon-by ,other))
 (ask myself do when receiving (set your ,variable to ?new-value)
      (do-old-behavior) ;;do it as normal
      (tell-other-new-value (quote ,variable) new-value (quote ,other))
      new-value))

(define-method-helper (tell-other-new-value variable new-value groups-name) something
 (ask myself ask your ,groups-name notice that ,variable of ,myself is now ,new-value))

(define-primitive-method (notice that ? of ? is now ?) something
 nil) ;;do nothing by default


(define-method (print {memq ?option '(memory variables script database all)}
		      on file ?file-name) something
 (help-comments
  |same as print ?option, except it gets printed to FILE-NAME, rather than terminal|
  |If a file already exists with FILE-NAME, this appends to the end of it|)
 (fancy-print option file-name))

(define-method (print {memq ?option '(memory variables script database all)}) something
 (help-comments
  |print my memory, variables, script or all ("all" is assumed if nothing given for OPTION)|)
  (fancy-print option))

(define-method (print) something
 (help-comments |same as (print all)|)
 (fancy-print 'all))

(define-method (print your ?variable) something
 (help-comments |Type out my value of "variable" on your terminal|)
 (type '(|;| ,(name-or-actor-of myself) |'s value of| ,variable
	     |is| ,(ask myself recall your ,variable))))

(defcomment print) ;;for tags
;printer for director

(setq *default-file-object nil)

(define-method-helper (fancy-print option (file-name)) something
 ;;option can be either script, memory, variables or database or all
 (let ((file-object
	(cond (*default-file-object)
	      ;;this is a stupid efficiency hack for printing many actors at once
	      (file-name
	       (cond ((probef file-name) (open file-name 'append))
		     (t (open file-name 'out)))))))
      (cond ((eq option 'all)
	     (fancy-print-variables file-object)
	     (fancy-print-memory file-object)
	     (terpri file-object)
	     (fancy-print-script file-object))
	    ((eq option 'script) (fancy-print-script file-object))
	    ((eq option 'memory)
	     (terpri file-object)
	     (fancy-print-variables file-object)
	     (fancy-print-memory file-object))
	    ((eq option 'database) (fancy-print-memory file-object))
	    ((eq option 'variables)
	     (fancy-print-variables file-object))
	    (t (shouldnt-happen 'fancy-print '(invalid print option ,option))))
      (or *default-file-object (and file-object (close file-object)))
      no-value))


(define-method-helper (fancy-print-script file-object) something
 ;;returns what the methods look like
  (terpri file-object)
  (princ '|My methods are | file-object)		 
  (do ((i (rest (methods-of myself)) (rest i)) ;;skip the first one
       (no-methods t))
      ((null (rest  i)) (cond (no-methods (princ '|none.| file-object)))
		no-value)
      (let ((method (first i)))
	   (cond ((or (normal-method? method) (value-method? method) (macro-method? method))
		  (setq no-methods nil)
		  (terpri file-object)
		  (let ((humanified-method (humanify-method method)))
		       (dicks-print (first humanified-method) file-object 'grind)
		       (mapc 
			(function (lambda (code-line)
					  (dicks-print code-line file-object 'grind)))
			(rest humanified-method))))))))

(define-method-helper (fancy-print-memory file-object) something
 (let ((items (ask myself recall your internal-name-of-items-memorized)))
      (cond (items
	     (terpri file-object)
	     (princ '|And I was told that | file-object)
	     (mapc
	      (function (lambda (item)
				(terpri file-object) ;;since they are seperate items
				(princ-or-print item file-object 'block)))
	      items)))))

(define-form (collect-all-variable-names actor)
 (let (((atomic-alist . non-atomic-alist) (internal-recall-your-variable-of actor)))
      '(parent !,(delq 'internal-name-of-items-memorized (mapcar 'car atomic-alist))
	       !,(mapcar 'car non-atomic-alist))))

(define-method-helper (fancy-print-variables file-object) something
 (terpri file-object)
 (do ((names (collect-all-variable-names myself) (rest names))
      (synonyms nil))
      ;;as synonyms discovered they are added to this so I don't print them twice
     ((null names) no-value)
     (let ((name (first names)))
	  (cond ((and (not (eq-first name 'synonyms-of)) ;;not a synonym marker
		      (not (member name synonyms)))
		 (let ((names-synonyms
			(second (look-up-variable-in-actor '(synonyms-of ,name) myself))))
		      (setq synonyms (append names-synonyms synonyms))
		      (print-name-value name
					(ask myself recall your ,name)
					names-synonyms
					file-object)))))))

(define-form (print-name-value name value synonyms file-object)
 (cond (name 
	(terpri file-object)
	(princ '|My | file-object)
	(princ name file-object)
	(cond (synonyms (princ '| (also known as | file-object)
			(princ-without-parens synonyms file-object)
			(princ '|)| file-object)))
	(princ '| is | file-object)
	(dicks-prin1 value file-object 'grind))))

(define-method (compare yourself with ?other) something
 (help-comments
   |Compares myself with OTHER and puts results in (comparsion-between ,myself ,OTHER)|)
 (let ((name (actor-of myself)))
      (let ((comparison (ask something make (comparison-between ,name ,other))))
	   (cond ((exists? other)
		  (let ((my-variables (ask myself list all your variable names))
			(others-variables (ask ,other list all your variable names)))
		       (do ((i (union my-variables others-variables) (rest i)))
			   ((null i))
			   (or
			    (eq (first i) 'name)
			    (let ((my-value (ask myself recall your ,(first i)))
				  (others-value (ask ,other recall your ,(first i))))
				 (cond ((not (equal my-value others-value))
					(ask ,comparison memorize
					     (difference type variable
							  variable ,(first i)
							  (,other value) ,others-value
							  (,name value) ,my-value)))))))))
		 (t (ask ,comparison memorize
			 (difference type existence
				      who-exists ,name
				      who-doesnt ,other))))
	   comparison)))


(define-method (compile message %message) something
 ;;this is a convient way to see how a message would be compiled
 (help-comments |return how a transmission of MESSAGE to me would be compiled|)
 (lispify-transmission myself message (name-of myself) nil))

(define-method (save %file-names) something
 (help-comments |save on FILE-NAMES a LOAD-able complete optimized description of myself|)
 (compile-and-print-actor (name-of myself) file-names)
 no-value)

(define-method (help %pattern) something
 (help-comments |describe what I do for all messages that match the PATTERN|
		|or all messages if no PATTERN is given|
		|to find out just what messages an actor can receive ask it to print script|)
 (let* ((name (name-of myself))
	(help-file '(,*help-storage-place ,name help))
	(help-holder '(help-for ,name))
	(parent (name-of (ask myself recall your parent))))
       (cond ((cond ((exists? help-holder)) ;;if its exists
		    ((probef help-file) ;;or is on disk
		     (ask something make ,help-holder)
		     (director-load help-file '(to get help for ,(name-of myself)))))
	      (mapc
	       (function (lambda (help)
				 (terpri) (terpri)
				 (princ (first help)) (princ '| |)
				 (princ-or-print (second help) nil 'grind)
				 (princ '| |)
				 (princ (third help))
				 (mapc (function (lambda (line) (type line)))
				       (nth-rest 3 help))))
	       (ask ,help-holder collect items memorized matching 
		    (|When receiving| ,(or pattern '?) I %))))
	     (t (type '|Sorry no help available|)))
       (cond (parent
	      (terpri)
	      (type '(|More help can be gotten by asking my parent| ,parent |for help|))
	      (terpri))))
 no-value)

(define-method (warning %some-warning) something
 (ask myself memorize ,some-warning)
 (warning (name-of myself) some-warning))

(define-method (should not happen %warning) something
 (ask myself memorize ,warning)
 (shouldnt-happen (name-of myself) warning))

(eval-when (eval) ;;due to bootstraping has to happen kinda late
	   (ask something set your private-variable-names to
		 ;;these guys are not inheirited (parent is treated specially)
		(offspring things-to-do-next name synonyms
			   whole parts internal-name-of-items-memorized))
	   (ask something set your clock to default-clock)
	   (ask something set your default-speed to 100.0))


(define-simple-macro (add-help-to-actor actor pattern comment) 
 (*add-help-to-actor actor pattern comment)
 nil)

(define-method-helper (*add-help-to-actor actor pattern comment) something
 ;;i want this cleverly compiled so that loading help files is quick
 (let ((helper '(help-for ,actor)))
      (cond ((not (exists? helper))
	     (ask something make ,helper)))
      (ask ,helper memorize (|When receiving| ,pattern I !,comment))))


;;this is the clock of actors with things planned used for interactions of actors
;;this assumes that things clean up after running schedule 

(define clock something
 (set your ticks-per-frame to 1)
 (set your frames-per-second to 1)
 (make synonym universe)) ;;to be compatible with old naming scheme

(define-method (tick) clock
 (help-comments |besides doing a normal tick I ask each of my actors-to-run-next to tick|)
 (do-old-behavior) ;;do anything planned too
 (let ((actors-to-run (ask myself recall your actors-to-run-next)))
      (ask myself set your actors-to-run-next to nil)
      (ask-each ,actors-to-run tick)))

(define-method (run for ?number ?units) clock
 (help-comments |repeatedly send myself a tick for NUMBER UNITS (ticks, frames or seconds)|)
 (let ((number (number-of-ticks number units)))
      (ask myself tick)
      (cond ((> number 1) ;;if number is an integer greater than 1
	     (ask myself run for ,(1- number) ticks)))))

(define default-clock clock)
