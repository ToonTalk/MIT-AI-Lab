;;*(PAGEWIDTH 64. 64. 0. 0.)

(DECLARE (GENPREFIX \GOB)
	 (FASLOAD GOODYS)
	 (FASLOAD !INTER)
	 (MACROS T))
(SETQ *HASH-TABLE-SIZE* 100.)

(SETQ *ANY '?)
(OR (BOUNDP 'CONTEXT-LIST) (SETQ  CONTEXT-LIST NIL) )

(DECLARE (SPECIAL *ANY *FACTS* *RECORD-OF-CMATCHS*
 CONTEXT-LIST CHRCT KEY ALIST CONTEXT *HASH-TABLE-SIZE*)
 (*LEXPR CMATCH CMATCH* CMATCH*ATOM CMATCH*FIRST GOBBLE*)
	 (*FEXPR  GF GOBBLE)) 

(SETQ *FACTS* '(FACTS TEMP-FACTS))



(DECLARE (SPECIAL *NEW-FACTS-POINTERS*))

(*DEFUN GOBBLE FEXPR (X) 
       (PROG (ALIST CONTEXT *NEW-FACTS-POINTERS*)
	     (SETQ CONTEXT (CAR X) 
		   CONTEXT-LIST 
		   (COND ((MEMQ CONTEXT CONTEXT-LIST)
				       CONTEXT-LIST)
			 (T (*ARRAY CONTEXT T *HASH-TABLE-SIZE*)
			    (CONS CONTEXT CONTEXT-LIST))) 
		   ALIST (LIST (CONS '* CONTEXT)))
	     (MAPC (FUNCTION ACCEPT) (CONVERT (CDR X)))
	     (AND (MEMQ CONTEXT *FACTS*)
		  (EQ (CAADR X) 'TIME-OF)
		  (LET-TIME-SPECIALIST-THINK-ABOUT-IT
		   CONTEXT))
	     (RETURN (CDAR ALIST))))

;;;THE GOBBLE-LEVEL KRUFT IS TO KNOW THE
;;;RECURSION LEVEL OF THE CALL TO GOBBLE
(DECLARE (SPECIAL *GOBBLE-LEVEL*))

(SETQ *GOBBLE-LEVEL* 0.)

(*DEFUN GOBBLE* N
	((LAMBDA (GOBBLE-LEVEL1)
		 ((LAMBDA (*GOBBLE-LEVEL*)
			(APPLY (FUNCTION GOBBLE)
			(LIST (COND ((= N 1.)'FACTS)
				     (T (ARG 2.)))
			      (ARG 1.))))
		  GOBBLE-LEVEL1))
	 (1+ *GOBBLE-LEVEL*)))

 

(*DEFUN CONVERT (L) 
       (COND ((ATOM L) L)
	     ((MEMQ (CAR L) '(AND OR XOR))
	      (MAKE-BINARY (CDR L) (CAR L)))
	     ((MAPCAR (FUNCTION CONVERT) L)))) 

(*DEFUN MAKE-BINARY (LIST OP) 
       (COND ((NULL LIST) NIL)
	     ((NULL (CDR LIST)) (CONVERT (CAR LIST)))
	     ((LIST OP
		    (CONVERT (CAR LIST))
		    (MAKE-BINARY (CDR LIST) OP))))) 



(*DEFUN ACCEPT (THING) 
   (COND
    ((AND    (EQ (CAR THING) 'TIME-OF)
	     (MEMQ CONTEXT *FACTS*))
	     (LOOK-FOR-INCONSISTENCIES THING CONTEXT))
    (T (ACCEPT1 THING))))

(*DEFUN ACCEPT1 (THING)
	    (COND ((CDR (ASSOC THING ALIST)))
		  ((ATOM THING) THING)
		  ((EQ (CAR THING) 'QUOTE)
		   ((LAMBDA (G) (PUTPROP G
				    (CADR THING)
				    'DATUM)
			    	(PUTPROP CONTEXT
					 (CONS G
					       (GET
						CONTEXT
						'QUOTED-LISTS))
					 'QUOTED-LISTS)
			   G)
	       (INTERN (GENSYM))))
	     ((EQ (CAR (EXPLODE (CAR THING)))
	        '*)
	      ((LAMBDA (U) 
		       (SETQ ALIST (CONS (CONS (CAR THING) U) ALIST))
		       U)
	       (ACCEPT1 (CDR THING))))
	     ((GET (CAR THING) 'LIKELIHOOD)
	      ((LAMBDA (U) (PUTPROP U (CAR THING) 'LIKELIHOOD)
			   U)
	       (ACCEPT1 (CADR THING))))
	     (T (*SAVE THING (MAPCAR 'ACCEPT1 THING))))) 

(*DEFUN *SAVE (X Y) 
       (PROG (ID)
	     (SETQ  ID (OR (PRESENT Y CONTEXT)
		       (NAME-DATUM Y CONTEXT (GENSYM))) 
		   ALIST (CONS (CONS X ID) ALIST))
	     (RETURN ID))) 

(DECLARE (UNSPECIAL ALIST CONTEXT)) 

(MACRODEF ATOMIFY (THING)
(COND ((NUMBERP THING) (IMPLODE (EXPLODE THING)))
      (T THING))) 

(MACRODEF DATUM (NAME) (GET NAME 'DATUM)) 

(*DEFUN PRESENT (PATTERN CONTEXT) (IN-LIST? PATTERN (KEY-LIST 
					     PATTERN
					     CONTEXT))) 
 

(*DEFUN CP N 
       (OR (AND (= N 2.) (ARG 2.)) (CURSORPOS 'C))
       ((LAMBDA (CONTEXT) 
		(COND ((NULL CONTEXT)
		       (*REMARK (LIST (ARG 1.)
				      'IS/ NOT/ A/ CONTEXT/.)))
		      ((DO ((I (REVERSE (CDR CONTEXT)) (CDR I)))
			   ((NULL I) (ASCII 0.))
			   (COND ((GET (CAR I) 'LIKELIHOOD)
		  (FUNCALL (COND ((AND (= N 2.)(NULL (ARG 2.)))
				  (FUNCTION
				   (LAMBDA (L)
					   (PRINT (DECODE L)))))
				 (T '*REMARK)) 
			   (LIST (GET (CAR I)
				      'LIKELIHOOD)
				 (CAR I))))
				 ((*UP (CAR I)(ARG 1.)))
		 ((FUNCALL (COND ((AND (= N 2.)(NULL (ARG 2.)))
		(FUNCTION
			(LAMBDA (L)
				(PRINT (DECODE L)))))
	(T '*REMARK)) (CAR I))))))))
	(FLATTEN-WITHOUT-DUPS (LISTARRAY (ARG 1.)))))

(*DEFUN FLATTEN-WITHOUT-DUPS (LIST)
	(DO ((I LIST (CDR I))
	     (ANS NIL))
	    ((NULL I) ANS)
	    (AND (CAR I)
		 (MAPC
		  (FUNCTION
		   (LAMBDA (ATOM)
			   (OR (MEMQ ATOM ANS)
			       (SETQ ANS (CONS ATOM ANS)))))
		  (CAR I)))))

(*DEFUN EQ-REMOVE-DUPLICATES (LIST) 
	(DO ((I (DELQ NIL (APPEND LIST NIL)) (CDR I)))
	    ((NULL I) LIST)
	    (DELQ (CAR I) (CDR I))
	    (AND (EQ (CAR I) (CADR I)) (RPLACD I (CDDR I)))))

(*DEFUN CFLUSH (CONTEXT) 
	(SETQ CONTEXT-LIST (DELQ CONTEXT CONTEXT-LIST))
	(REMPROP CONTEXT 'QUOTED-LISTS)
	(*REARRAY CONTEXT))
 

(*DEFUN IN-LIST? (PATTERN LIST) 
       (DO ((I LIST (CDR I)) (ANS NIL))
	   ((OR ANS (NULL I)) ANS)
	   (AND (MATCH-IT PATTERN (DATUM (CAR I)))
		(SETQ ANS (CAR I))))) 

(*DEFUN MATCH-IT (X Y) 
       (AND (OR (EQUAL (CAR X) (CAR Y)) (EQ (CAR X) '?))
	    (OR (EQUAL (CADR X) (CADR Y)) (EQ (CADR X) '?))
	    (COND ((AND(CDDR X)(CDDR Y))
		   (OR (EQUAL (CADDR X) (CADDR Y))
		       (EQ (CADDR X) '?)))
		  ((AND (NULL (CDDR X))(NULL (CDDR Y)))))))

(*DEFUN FETCHI (PATTERN CONTEXT)
       (DO ((I (KEY-LIST PATTERN CONTEXT) (CDR I)) (ANS NIL))
	   ((NULL I) ANS)
	   (AND (MATCH-IT PATTERN (DATUM (CAR I)))
		(SETQ ANS (CONS (CAR I) ANS))))) 

(DECLARE (SPECIAL ALIST STAR-VALUE)) 

 

(*DEFUN DECODE (CONCEPT) 
       (COND ((ATOM CONCEPT)
	      ((LAMBDA (U) 
		       (COND (U (MAPCAR (FUNCTION DECODE) U))
			     (T CONCEPT)))
	       (DATUM CONCEPT)))
	     (T (MAPCAR (FUNCTION DECODE) CONCEPT)))) 

(DECLARE (SPECIAL CONTEXT)) 

(*DEFUN CMATCH N
	(COND ((ATOM (ARG 1.)) (*UP (ARG 1.) CONTEXT))
	      ((= N 1.) (LMATCH (ARG 1.) CONTEXT-LIST))
	      ((ATOM (ARG 2.))
	       (AND (MEMQ (ARG 2.) CONTEXT-LIST)
		    ((LAMBDA (CONTEXT)
			       (CM (ARG 1.))) (ARG 2.))))
	      (T (LMATCH (ARG 1.) (ARG 2.))))) 

(*DEFUN CM (X) 
       (COND
	((NULL (CDDR X))
	 (COND ((ATOM (CADR X)) (FETCHI  X CONTEXT ))
	       ((MAPCAN 
		 (FUNCTION (LAMBDA (Q) 
				   (FETCHI (LIST (CAR X) Q)
					   CONTEXT)))
		 (CM (CADR X))))))
	((ATOM (CADDR X))
	 (COND
	  ((ATOM (CADR X)) (FETCHI X CONTEXT ))
	  ((MAPCAN 
	    (FUNCTION (LAMBDA (Q) 
			      (FETCHI    (CONS (CAR X)
					       (CONS Q
						     (CDDR X)))
				      CONTEXT)))
	    (CM (CADR X))))))
	((ATOM (CADR X))
	 (MAPCAN (FUNCTION (LAMBDA (Q) (FETCHI (LIST 
						     (CAR X)
						     (CADR X)
						     Q)
					       CONTEXT)))
		 (CM (CADDR X))))
	(((LAMBDA (U) 
	   (AND
	    U
	    (DO
	     ((I (CM (CADR X)) (CDR I)) (KEY (CAR X)) (ANS NIL))
	     ((NULL I) ANS)
	     (SETQ 
	      ANS
	      (APPEND ANS
		      (MAPCAN (FUNCTION (LAMBDA (Q) 
					(FETCHI (LIST 
						 KEY
						 (CAR I)
						 Q)
						CONTEXT)))
			      U))))))
	  (CM (CADDR X)))))) 

(DECLARE (UNSPECIAL CONTEXT))



(MACRODEF CHECK-TO-SEE-IF-GOOD (POINTERS CONTEXT)
	  (COND( (EQ(CAR (ARG 1.)) 'TIME-OF)
	       (CHECK-TO-SEE-IF-GOOD1 POINTERS CONTEXT))
		(T POINTERS)))

(*DEFUN CMATCH* N 
((LAMBDA (L-OR-C-MATCH )
	(COND ((= N 1.) (DECODE(CHECK-TO-SEE-IF-GOOD
				(LMATCH (ARG 1.) 
					*FACTS*)
				*FACTS*)))
	      ((= N 2.) (DECODE (CHECK-TO-SEE-IF-GOOD
				 (FUNCALL
				 L-OR-C-MATCH
				 (ARG 1.) (ARG 2.))
				 (ARG 2.))))
	      (T ((LAMBDA (THOSE-FOUND) 
			  (AND THOSE-FOUND
			       (ARG 3.) 
			       (MAPCAR (ARG 3.) THOSE-FOUND)))
		  (DECODE((LAMBDA (GENSYMS)
			   (AND
			    (> N 3.)
			    (ARG 4.)
			     (AND
			      (BOUNDP '*RECORD-OF-CMATCHS*)
			      (SETQ *RECORD-OF-CMATCHS*
				    (APPEND
				     *RECORD-OF-CMATCHS*
				     GENSYMS))))
			   GENSYMS)
			  (CHECK-TO-SEE-IF-GOOD
			   (FUNCALL
			  L-OR-C-MATCH
			  (ARG 1.) (ARG 2.))
			   (ARG 2.))))))))
(COND ((OR(= N 1)
	(ATOM (ARG 2.)))
       'CMATCH)
      (T 'LMATCH))))



(*DEFUN CHECK-TO-SEE-IF-GOOD1 (POINTERS CONTEXT)
  (DO ((POINTERS POINTERS (CDR POINTERS))
       (ANS NIL))
      ((NULL POINTERS) (REVERSE ANS))
      ((LAMBDA (BELIEVABILITY-OF-IT)
	   (COND
		((NULL BELIEVABILITY-OF-IT)
		  (SETQ ANS (CONS (CAR POINTERS) ANS)))
		 ((= (LENGTH BELIEVABILITY-OF-IT) 1.)
		  (AND
		   (EQ (GOODNESS
				 (DATUM BELIEVABILITY-OF-IT))
		     'GOOD)
		  (SETQ ANS (CONS (CAR POINTERS) ANS))))
		 ((EQ
		   (FIND-MOST-RECENT-BELIEVABILITY
		     BELIEVABILITY-OF-IT)
		   'GOOD)
		   (SETQ ANS (CONS (CAR POINTERS) ANS)))))
       (CMATCH 
	(CONS-BELIEVABILITY (CAR POINTERS) '?)
	CONTEXT))))

(*DEFUN GET-CONTEXT (POINTER)
	(CAR (DATUM POINTER)))



(*DEFUN CMATCH*ATOM N
((LAMBDA (ARG-LIST)
 (ATOM-ONLY (APPLY (FUNCTION CMATCH*) ARG-LIST) ARG-LIST))
(LISTIFY N)))

(*DEFUN CMATCH*FIRST N
 (CAR (APPLY (FUNCTION CMATCH*) (LISTIFY N))))

(*DEFUN CMATCH*LAST N
 (CAR(LAST (APPLY (FUNCTION CMATCH*) (LISTIFY N)))))

(*DEFUN ATOM-ONLY (THING ARG-LIST) 
       (COND ((NULL THING) THING)
	   ((= (LENGTH THING) 1.) (CAR THING)) 
	     (T (*ERROR 'ATOM-ONLY
			(LIST THING (CONS 'CMATCH* ARG-LIST)) 
		(LIST THING 'SHOULD/ BE/ ONLY/ ONE/ ELEMENT)))))

;;;REPLACED BY CAR IN NEWER LISP VERSIONS
;;;(*DEFUN FIRST-ONLY (THING) 
;;;       (COND ((NULL THING) THING)
;;;	   (T (CAR THING))))

(*DEFUN LMATCH (PATTERN C-LIST) 
       (COND ((ATOM C-LIST) (CMATCH PATTERN C-LIST))
	     (T (DO ((I C-LIST (CDR I)) (ANS NIL))
		    ((NULL I) ANS)
		    (SETQ ANS (APPEND ANS
				      (CMATCH PATTERN (CAR I)))))))) 

(*DEFUN *REMARK (X) 
       (TERPRI)
       (PRINC '/././.)
       (MAPC (FUNCTION (LAMBDA (Q) 
			       (COND ((> (LENGTH (EXPLODE Q)) CHRCT)
				      (TERPRI)
				      (PRINC '/ / / )))
			       (PRINC Q)
			       (PRINC '/ )))
	     (FLATTEN X))
       (TERPRI)
       (ASCII 0.)) 

(*DEFUN FLATTEN (X) 
       (COND ((NULL X) NIL)
	     ((ATOM X)
	      (COND ((GET X 'DATUM)
		     (FLATTEN (ENGLISHIFY1 (DECODE X))))
		    (T (LIST X))))
	     ((EQ (CAR X) 'AND) (FL1 X 'AND))
	     ((EQ (CAR X) 'OR) (FL1 X 'OR))
	     (T (APPEND (FLATTEN (CAR X)) (FLATTEN (CDR X)))))) 

(*DEFUN FL1 (Y CODE) 
       (APPEND (FLATTEN (CADR Y))
	       (MAPCAN (FUNCTION (LAMBDA (Q) (CONS CODE (FLATTEN Q))))
		       (CDDR Y)))) 

(*DEFUN *UP (THING CONTEXT) 
       (COND ((ATOM THING)
	      (COND ((EQ CONTEXT *ANY) 
		     (LMATCH THING CONTEXT-LIST))
		     ((UNION
		      (CMATCH (LIST '? THING '?) CONTEXT)
		      (UNION
		       (CMATCH (LIST '? '? THING) CONTEXT)
		       (CMATCH (LIST '? THING) CONTEXT))))))
	     ((MAPCAN 
	       (FUNCTION (LAMBDA (Q)
				 (*UP Q CONTEXT)))
	       (CMATCH THING CONTEXT))))) 

(*DEFUN *ALL (KEY FORM CONTEXT) 
(PRINT 'WATCH-OUT-NOT-REDONE-FOR-NEW-GOBBLE)
       (PROG (L ANS) 
	     (SETQ L (CMATCH KEY CONTEXT) ANS (CMATCH FORM CONTEXT))
	LOOP (COND ((NULL L) (RETURN ANS))
		   ((MEMQ (CAR L) ANS) (SETQ L (CDR L)))
		   ((SETQ ANS
			  (UNION ANS
				 (CMATCH (SUBST (CAR L) KEY FORM)
					 CONTEXT))
			  L
			  (UNION (CDR L) (*UP (CAR L) CONTEXT)))))
	     (GO LOOP))) 

(*DEFUN UNION (X Y) 
       (PROG NIL 
	LOOP (COND ((NULL X) (RETURN Y))
		   ((MEMQ (CAR X) Y))
		   ((SETQ Y (CONS (CAR X) Y))))
	     (SETQ X (CDR X))
	     (GO LOOP))) 

(*DEFUN NTH (X N) 
       (AND (NUMBERP N)
	    (DO ((I X (CDR I)) (J 1. (1+ J)))
		((OR (= J N) (NULL I)) (AND I (CAR I)))))) 

(*DEFUN FUNCTION-ARG (KEY THING CNTXT) 
(PRINT 'WATCH-OUT-NOT-REDONE-FOR-NEW-GOBBLE)
 (MAPCAR (FUNCTION (LAMBDA (U) (CDR (DECODE U))))
	       (*ALL THING (LIST KEY THING *ANY) CNTXT))) 

(*DEFUN FUNCTION-VALUE (KEY THING CNTXT) 
(PRINT 'WATCH-OUT-NOT-REDONE-FOR-NEW-GOBBLE)
       (MAPCAR (FUNCTION (LAMBDA (U) (CDR (DECODE U))))
	       (*ALL THING (LIST KEY *ANY THING) CNTXT))) 

 

(DECLARE (SPECIAL CONTEXT))


;;;RE-DO
(*DEFUN REMOVE-ALL-BELOW (ATOM)
	(DO ((I (CDR (DATUM ATOM)) (CDR I))
	     (J (CDR KEYLIST) (CDR J)))
	    ((NULL I) NIL)
	    (COND ((NUMBERP (CAR I)))
		  ((NULL ATOM))
		  (T (AND (< (LENGTH (*UP (CAR I)
					  CONTEXT))
			     2.)
			  (DATUM (CAR I))
			  (REMOVE-ALL-BELOW (CAR I)))
		     (REMOVE-FROM-LIST&GC (CAR I)
					  ATOM
					  (CAR J)))))) 

(*DEFUN REPLACE-ATOM (ATOM NEW-EXPRESSION POSITION) 
       (PROG (ALIST CONTEXT OLD-EXP KEY) 
	     (SETQ CONTEXT (CAR (DATUM ATOM)))
	     (SETQ ALIST (LIST (CONS '* CONTEXT)))
	     (PUTPROP ATOM
		      (SUBST (ACCEPT NEW-EXPRESSION)
			     (SETQ OLD-EXP
				   (NTH (CDR (DATUM ATOM)) POSITION))
			     (DATUM ATOM))
		      'DATUM)
	     (REMOVE-ALL-BELOW OLD-EXP)
	     (REMOVE-FROM-LIST&GC OLD-EXP
				  ATOM
				  (NTH (CDR KEYLIST) POSITION)))) 

(*DEFUN REMOVE-FROM-LIST&GC (ATOM THING FLAG) 
       (REMOVE-FROM-LIST ATOM THING FLAG)
       (OR (GET ATOM 'FIRST)
	   (GET ATOM 'SECOND)
	   (GET ATOM 'THIRD)
	   (AND (DATUM ATOM)
		(REMOVE-FROM-LIST CONTEXT ATOM 'CONTEXT)
		(REMPROP ATOM 'DATUM)))) 

(DECLARE (UNSPECIAL CONTEXT)) 

(*DEFUN REMOVE-TOP-LEVEL (ATOM) 
       (PROG (CONTEXT) 
	     (SETQ CONTEXT (CAR (DATUM ATOM)))
	     (COND
	      ((*UP ATOM '?)
	       (PRINT (LIST 'ONLY/ REMOVE/ TOP/ LEVEL/ EXPRESSIONS
			    ATOM)))
	      (T (REMOVE-ALL-BELOW ATOM)
		 (REMOVE-FROM-LIST CONTEXT ATOM 'CONTEXT)
		 (REMPROP ATOM 'DATUM))))) 


;;;THIS WAS ENGLISH >
;;;RE-WRITTEN 7-24-74

 

(DECLARE (SPECIAL MOST-RECENT EXP)) 

(SETQ MOST-RECENT NIL) 

(*DEFUN ENGLISHIFY (X) (*REMARK (ENGLISHIFY1 (DECODE X)))) 

(*DEFUN ENGLISHIFY1 (EXP) 
       (COND ((ATOM EXP) EXP)
	     ((> (LENGTH EXP) 3.) EXP)
	     ((ATOM (CAR EXP))
	      (OR (MAPCAR 'EVAL
			  (GET (CAR EXP) 'ENGLISH))
		  (LIST (CAR EXP) (*ARG) (VALUE))))
	     (T (LIST (ENGLISHIFY1 (CAR EXP)) (*ARG) (VALUE))))) 

(*DEFUN *ARG NIL (ENGLISHIFY1 (CADR EXP)))

(*DEFUN VALUE NIL (ENGLISHIFY1 (CADDR EXP))) 



(MACRODEF STORE-IN-TABLE (THING)
((LAMBDA (LOCATION)
 ((LAMBDA (BUCKET)
  (STORE 
   (ARRAYCALL T ARRAY-POINTER LOCATION)
   (OR 
    (MEMQ NAME
	  BUCKET)
    (CONS NAME
	BUCKET))))
   (ARRAYCALL T ARRAY-POINTER LOCATION)))
 (\ (SXHASH THING) *HASH-TABLE-SIZE*)))



(*DEFUN NAME-DATUM (THING CONTEXT NAME)
(PUTPROP NAME THING 'DATUM)
((LAMBDA (FIRST SECOND THIRD ARRAY-POINTER)
 (STORE-IN-TABLE THING)
(COND ((NULL (CDDR THING))
       (STORE-IN-TABLE
	(LIST '? SECOND))
       (STORE-IN-TABLE
	(LIST FIRST '?)))
      (T 
       (STORE-IN-TABLE
     (LIST '? SECOND THIRD))
    (STORE-IN-TABLE
     (LIST FIRST '? '?))
    (STORE-IN-TABLE
     (LIST FIRST '? THIRD))
    (STORE-IN-TABLE
     (LIST '? SECOND '?))
    (STORE-IN-TABLE
     (LIST FIRST SECOND '?))
    (STORE-IN-TABLE
     (LIST '? '? THIRD)))))
 (CAR THING)
 (CADR THING)
 (CADDR THING)
 (GET CONTEXT 'ARRAY))
NAME)

(*DEFUN KEY-LIST (PATTERN CONTEXT)
       (ARRAYCALL T (GET CONTEXT 'ARRAY)
	(\ (SX-HASH PATTERN) *HASH-TABLE-SIZE*)))
    